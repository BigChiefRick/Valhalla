package generators

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"valhalla/internal/logger"
	"valhalla/internal/models"
)

// PulumiGenerator generates Pulumi programs
type PulumiGenerator struct {
	*BaseGenerator
	language string
}

// NewPulumiGenerator creates a new Pulumi generator
func NewPulumiGenerator(language string, log *logger.Logger) Generator {
	return &PulumiGenerator{
		BaseGenerator: NewBaseGenerator("pulumi", fmt.Sprintf("pulumi-%s", language), log),
		language:      language,
	}
}

// Generate creates Pulumi programs from infrastructure models
func (g *PulumiGenerator) Generate(infrastructures []*models.Infrastructure, opts GenerateOptions) ([]*GenerateResult, error) {
	g.Log().Info("Generating Pulumi templates", "language", g.language, "infrastructures", len(infrastructures))

	var results []*GenerateResult

	// Generate Pulumi.yaml
	pulumiYaml := g.generatePulumiYaml()
	results = append(results, &GenerateResult{
		Path:      "Pulumi.yaml",
		Content:   []byte(pulumiYaml),
		Size:      len(pulumiYaml),
		Type:      "config",
		Provider:  "pulumi",
		Resources: []string{},
	})

	// Generate language-specific files
	for _, infra := range infrastructures {
		providerResults, err := g.generateForProvider(infra, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate for provider %s: %w", infra.Provider, err)
		}
		results = append(results, providerResults...)
	}

	// Generate package file based on language
	packageFile := g.generatePackageFile()
	if packageFile != nil {
		results = append(results, packageFile)
	}

	// Write files if not dry run
	if !opts.DryRun {
		for _, result := range results {
			if err := g.writeFile(result, opts.OutputDir); err != nil {
				return nil, fmt.Errorf("failed to write file %s: %w", result.Path, err)
			}
		}
	}

	return results, nil
}

// generatePulumiYaml generates the Pulumi.yaml project file
func (g *PulumiGenerator) generatePulumiYaml() string {
	runtime := g.language
	if g.language == "typescript" {
		runtime = "nodejs"
	}

	return fmt.Sprintf(`name: valhalla-infrastructure
runtime: %s
description: Infrastructure discovered and generated by Valhalla

config:
  # Provider-specific configuration
  vsphere:server:
    description: vSphere server address
  vsphere:user:
    description: vSphere username
    secret: true
  vsphere:password:
    description: vSphere password
    secret: true
  vsphere:allowUnverifiedSsl:
    description: Allow unverified SSL certificates
    default: true
`, runtime)
}

// generatePackageFile generates language-specific package files
func (g *PulumiGenerator) generatePackageFile() *GenerateResult {
	switch g.language {
	case "python":
		return &GenerateResult{
			Path:      "requirements.txt",
			Content:   []byte("pulumi>=3.0.0,<4.0.0\npulumi-vsphere>=4.0.0,<5.0.0\n"),
			Size:      50,
			Type:      "package",
			Provider:  "pulumi",
			Resources: []string{},
		}
	case "typescript":
		packageJson := `{
  "name": "valhalla-infrastructure",
  "version": "1.0.0",
  "description": "Infrastructure discovered and generated by Valhalla",
  "main": "index.ts",
  "scripts": {
    "build": "tsc",
    "start": "pulumi up"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "typescript": "^4.0.0"
  },
  "dependencies": {
    "@pulumi/pulumi": "^3.0.0",
    "@pulumi/vsphere": "^4.0.0"
  }
}`
		return &GenerateResult{
			Path:      "package.json",
			Content:   []byte(packageJson),
			Size:      len(packageJson),
			Type:      "package",
			Provider:  "pulumi",
			Resources: []string{},
		}
	case "go":
		goMod := `module valhalla-infrastructure

go 1.18

require (
	github.com/pulumi/pulumi/sdk/v3 v3.0.0
	github.com/pulumi/pulumi-vsphere/sdk/v4 v4.0.0
)
`
		return &GenerateResult{
			Path:      "go.mod",
			Content:   []byte(goMod),
			Size:      len(goMod),
			Type:      "package",
			Provider:  "pulumi",
			Resources: []string{},
		}
	case "csharp":
		csproj := `<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Pulumi" Version="3.*" />
    <PackageReference Include="Pulumi.VSphere" Version="4.*" />
  </ItemGroup>

</Project>
`
		return &GenerateResult{
			Path:      "valhalla-infrastructure.csproj",
			Content:   []byte(csproj),
			Size:      len(csproj),
			Type:      "package",
			Provider:  "pulumi",
			Resources: []string{},
		}
	}
	return nil
}

// generateForProvider generates Pulumi code for a specific provider
func (g *PulumiGenerator) generateForProvider(infra *models.Infrastructure, opts GenerateOptions) ([]*GenerateResult, error) {
	switch strings.ToLower(infra.Provider) {
	case "vmware", "vsphere":
		return g.generateVMware(infra, opts)
	case "proxmox":
		return g.generateProxmox(infra, opts)
	case "nutanix":
		return g.generateNutanix(infra, opts)
	default:
		return nil, fmt.Errorf("unsupported provider: %s", infra.Provider)
	}
}

// generateVMware generates Pulumi code for VMware infrastructure
func (g *PulumiGenerator) generateVMware(infra *models.Infrastructure, opts GenerateOptions) ([]*GenerateResult, error) {
	var content string
	var filename string

	switch g.language {
	case "python":
		content = g.generateVMwarePython(infra)
		filename = "__main__.py"
	case "typescript":
		content = g.generateVMwareTypeScript(infra)
		filename = "index.ts"
	case "go":
		content = g.generateVMwareGo(infra)
		filename = "main.go"
	case "csharp":
		content = g.generateVMwareCSharp(infra)
		filename = "Program.cs"
	default:
		return nil, fmt.Errorf("unsupported language: %s", g.language)
	}

	return []*GenerateResult{{
		Path:      filename,
		Content:   []byte(content),
		Size:      len(content),
		Type:      "main",
		Provider:  "vmware",
		Resources: []string{"vsphere_virtual_machine"},
	}}, nil
}

// generateVMwarePython generates Python Pulumi code
func (g *PulumiGenerator) generateVMwarePython(infra *models.Infrastructure) string {
	code := `import pulumi
import pulumi_vsphere as vsphere

# Get configuration
config = pulumi.Config()

# Get datacenter
datacenter = vsphere.get_datacenter(name=config.require("datacenter"))

# Get compute cluster
cluster = vsphere.get_compute_cluster(
    name=config.require("cluster"),
    datacenter_id=datacenter.id
)

`

	// Generate data sources for networks and datastores
	networks := make(map[string]bool)
	datastores := make(map[string]bool)

	for _, vm := range infra.VirtualMachines {
		for _, nic := range vm.NetworkCards {
			if nic.Network != "" {
				networks[nic.Network] = true
			}
		}
		for _, disk := range vm.Disks {
			if disk.Datastore != "" {
				datastores[disk.Datastore] = true
			}
		}
	}

	for network := range networks {
		resourceName := g.GenerateResourceName(network)
		code += fmt.Sprintf(`# Get network: %s
%s = vsphere.get_network(
    name="%s",
    datacenter_id=datacenter.id
)

`, network, resourceName, network)
	}

	for datastore := range datastores {
		resourceName := g.GenerateResourceName(datastore)
		code += fmt.Sprintf(`# Get datastore: %s
%s = vsphere.get_datastore(
    name="%s",
    datacenter_id=datacenter.id
)

`, datastore, resourceName, datastore)
	}

	// Generate VMs
	code += "# Virtual Machines\n"
	for _, vm := range infra.VirtualMachines {
		if vm.Config.Template {
			continue
		}

		resourceName := g.GenerateResourceName(vm.Name)
		datastoreResourceName := g.GenerateResourceName(vm.Disks[0].Datastore)
		
		code += fmt.Sprintf(`%s = vsphere.VirtualMachine("%s",
    name="%s",
    resource_pool_id=cluster.resource_pool_id,
    datastore_id=%s.id,
    num_cpus=%d,
    memory=%d,
    guest_id="%s",
    network_interfaces=[`,
			resourceName, resourceName, vm.Name, datastoreResourceName,
			vm.CPUs, vm.Memory, vm.Config.GuestID)

		// Add network interfaces
		for i, nic := range vm.NetworkCards {
			networkResourceName := g.GenerateResourceName(nic.Network)
			if i > 0 {
				code += ","
			}
			code += fmt.Sprintf(`
        vsphere.VirtualMachineNetworkInterfaceArgs(
            network_id=%s.id,
            adapter_type="%s"
        )`, networkResourceName, nic.Type)
		}

		code += "\n    ],\n    disks=["

		// Add disks
		for i, disk := range vm.Disks {
			datastoreResourceName := g.GenerateResourceName(disk.Datastore)
			if i > 0 {
				code += ","
			}
			code += fmt.Sprintf(`
        vsphere.VirtualMachineDiskArgs(
            label="disk%d",
            size=%d,
            thin_provisioned=%t,
            datastore_id=%s.id
        )`, i, disk.Size, strings.Contains(disk.Type, "thin"), datastoreResourceName)
		}

		code += "\n    ]\n)\n\n"
	}

	// Add exports
	code += "# Exports\n"
	for _, vm := range infra.VirtualMachines {
		if vm.Config.Template {
			continue
		}
		resourceName := g.GenerateResourceName(vm.Name)
		code += fmt.Sprintf(`pulumi.export("%s_id", %s.id)
pulumi.export("%s_ip", %s.default_ip_address)
`, vm.Name, resourceName, vm.Name, resourceName)
	}

	return code
}

// generateVMwareTypeScript generates TypeScript Pulumi code
func (g *PulumiGenerator) generateVMwareTypeScript(infra *models.Infrastructure) string {
	code := `import * as pulumi from "@pulumi/pulumi";
import * as vsphere from "@pulumi/vsphere";

// Get configuration
const config = new pulumi.Config();

// Get datacenter
const datacenter = vsphere.getDatacenter({
    name: config.require("datacenter")
});

// Get compute cluster
const cluster = vsphere.getComputeCluster({
    name: config.require("cluster"),
    datacenterId: datacenter.then(dc => dc.id)
});

`

	// Generate data sources for networks and datastores
	networks := make(map[string]bool)
	datastores := make(map[string]bool)

	for _, vm := range infra.VirtualMachines {
		for _, nic := range vm.NetworkCards {
			if nic.Network != "" {
				networks[nic.Network] = true
			}
		}
		for _, disk := range vm.Disks {
			if disk.Datastore != "" {
				datastores[disk.Datastore] = true
			}
		}
	}

	for network := range networks {
		resourceName := g.GenerateResourceName(network)
		code += fmt.Sprintf(`// Get network: %s
const %s = vsphere.getNetwork({
    name: "%s",
    datacenterId: datacenter.then(dc => dc.id)
});

`, network, resourceName, network)
	}

	for datastore := range datastores {
		resourceName := g.GenerateResourceName(datastore)
		code += fmt.Sprintf(`// Get datastore: %s
const %s = vsphere.getDatastore({
    name: "%s",
    datacenterId: datacenter.then(dc => dc.id)
});

`, datastore, resourceName, datastore)
	}

	// Generate VMs
	code += "// Virtual Machines\n"
	for _, vm := range infra.VirtualMachines {
		if vm.Config.Template {
			continue
		}

		resourceName := g.GenerateResourceName(vm.Name)
		datastoreResourceName := g.GenerateResourceName(vm.Disks[0].Datastore)
		
		code += fmt.Sprintf(`const %s = new vsphere.VirtualMachine("%s", {
    name: "%s",
    resourcePoolId: cluster.then(c => c.resourcePoolId),
    datastoreId: %s.then(ds => ds.id),
    numCpus: %d,
    memory: %d,
    guestId: "%s",
    networkInterfaces: [`,
			resourceName, resourceName, vm.Name, datastoreResourceName,
			vm.CPUs, vm.Memory, vm.Config.GuestID)

		// Add network interfaces
		for i, nic := range vm.NetworkCards {
			networkResourceName := g.GenerateResourceName(nic.Network)
			if i > 0 {
				code += ","
			}
			code += fmt.Sprintf(`
        {
            networkId: %s.then(net => net.id),
            adapterType: "%s"
        }`, networkResourceName, nic.Type)
		}

		code += "\n    ],\n    disks: ["

		// Add disks
		for i, disk := range vm.Disks {
			datastoreResourceName := g.GenerateResourceName(disk.Datastore)
			if i > 0 {
				code += ","
			}
			code += fmt.Sprintf(`
        {
            label: "disk%d",
            size: %d,
            thinProvisioned: %t,
            datastoreId: %s.then(ds => ds.id)
        }`, i, disk.Size, strings.Contains(disk.Type, "thin"), datastoreResourceName)
		}

		code += "\n    ]\n});\n\n"
	}

	// Add exports
	code += "// Exports\n"
	for _, vm := range infra.VirtualMachines {
		if vm.Config.Template {
			continue
		}
		resourceName := g.GenerateResourceName(vm.Name)
		code += fmt.Sprintf(`export const %s_id = %s.id;
export const %s_ip = %s.defaultIpAddress;
`, strings.ReplaceAll(vm.Name, "-", "_"), resourceName, strings.ReplaceAll(vm.Name, "-", "_"), resourceName)
	}

	return code
}

// generateVMwareGo generates Go Pulumi code
func (g *PulumiGenerator) generateVMwareGo(infra *models.Infrastructure) string {
	// TODO: Implement Go code generation
	return `package main

import (
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		// TODO: Implement VMware infrastructure in Go
		return nil
	})
}
`
}

// generateVMwareCSharp generates C# Pulumi code
func (g *PulumiGenerator) generateVMwareCSharp(infra *models.Infrastructure) string {
	// TODO: Implement C# code generation
	return `using System.Collections.Generic;
using Pulumi;
using VSphere = Pulumi.VSphere;

return await Deployment.RunAsync(() =>
{
    // TODO: Implement VMware infrastructure in C#
});
`
}

// generateProxmox generates Pulumi code for Proxmox infrastructure
func (g *PulumiGenerator) generateProxmox(infra *models.Infrastructure, opts GenerateOptions) ([]*GenerateResult, error) {
	// TODO: Implement Proxmox Pulumi generation
	g.Log().Info("Proxmox Pulumi generation not yet implemented")
	return []*GenerateResult{}, nil
}

// generateNutanix generates Pulumi code for Nutanix infrastructure
func (g *PulumiGenerator) generateNutanix(infra *models.Infrastructure, opts GenerateOptions) ([]*GenerateResult, error) {
	// TODO: Implement Nutanix Pulumi generation
	g.Log().Info("Nutanix Pulumi generation not yet implemented")
	return []*GenerateResult{}, nil
}

// writeFile writes a generate result to a file
func (g *PulumiGenerator) writeFile(result *GenerateResult, outputDir string) error {
	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write file
	filePath := filepath.Join(outputDir, result.Path)
	if err := os.WriteFile(filePath, result.Content, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	result.Path = filePath
	return nil
}

// GetSupportedFormats returns supported output formats
func (g *PulumiGenerator) GetSupportedFormats() []string {
	return []string{
		"pulumi-python",
		"pulumi-typescript",
		"pulumi-go",
		"pulumi-csharp",
	}
}

// Validate validates the generated templates
func (g *PulumiGenerator) Validate(results []*GenerateResult) error {
	// TODO: Implement Pulumi validation
	g.Log().Info("Pulumi validation not yet implemented")
	return nil
}
